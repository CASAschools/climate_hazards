```{r, message = FALSE}
library(sf)
library(tidyverse)
library(here)
library(tmap)
library(terra)
```

Read in data
```{r, message = FALSE}
# read in sea level rise rasters
slr_coast <- rast("/capstone/casaschools/sea_level_rise/raw_data/slr_coast_0.5m_jdr.tif")

slr_delta <- rast("/capstone/casaschools/sea_level_rise/raw_data/slr_delta_0.5m_jdr.tif")

slr_sfbay <- rast("/capstone/casaschools/sea_level_rise/raw_data/slr_sfbay_0.5m_jdr.tif")

# read in california schools data
ca_districts <- st_read("/capstone/casaschools/schools_data/California_School_District_Areas_2022-23/",
                        quiet = TRUE)
```
Our sea level rise rasters show the extent and depth of flooding under a .5m sea level rise scenario and under a 100-year storm scenario for the california coast, san francisco bay, and sacramento river delta area. 

exploratory analysis
```{r}
# resolution (meters)
res(slr_sfbay)

res(slr_coast)

res(slr_delta)

# plot each of them
plot(slr_sfbay)

plot(slr_coast)

plot(slr_delta)

# crs
st_crs(ca_districts)

st_crs(slr_coast)
```

First, we are going to need to resample the rasters to be the same resolution, so that we can stitch them together. We use a bilinear interpolation method because our data are numeric and continuous. Then, we are going to create a mosaic with the rasters to have one raster for sea level rise in California

```{r}
# resample the sfbay and delta rasters to be 50m
slr_delta <- resample(slr_delta, slr_coast, method = "bilinear")

slr_sfbay <- resample(slr_sfbay, slr_coast, method = "bilinear")

# check to make sure that the resample worked
res(slr_delta) == res(slr_coast)

res(slr_sfbay) == res(slr_coast)

# create a raster mosaic. "fun" determines what to do with overlaps. In this case, we'll take the mean of overlapping cells
slr_ca <- mosaic(slr_coast, slr_delta, slr_sfbay, fun = "mean")

# check the new raster
res(slr_ca)

plot(slr_ca)
```

Now, we're ready to combine with school districts. Here, we'll be finding the area of each school district that is covered by our rasters. This will help us find the area of overlap of coastal flooding with each school district. First, we need to make sure that the raster is on the same crs as the schools

```{r}
# reproject the raster to be on the same crs as our schools layer
slr_ca <- project(slr_ca, ca_districts)

# vectorize our raster layer
slr_schools <- as.polygons(slr_ca, round = TRUE, aggregate = TRUE, values = TRUE, extent = FALSE, digits = 0)

slr_schools2 <- as.polygons(slr_ca, values = FALSE)

# convert our vector layer into an sf object
slr_schools <- st_as_sf(slr_schools)

slr_schools2 <- st_as_sf(slr_schools2)

# dissolve the boundaries of our vector layer so we have one large shape
slr_schools_test <- st_union(slr_schools)
```

```{r}
# find the intersections
slr_districts <- st_intersection(ca_districts, slr_schools_test)

# find the area of each intersection polygon
slr_districts$slr_area <- st_area(slr_districts)

# also find the area of each original district polygon to compare
ca_districts$area <- st_area(ca_districts)

## join the two together
# select only neccessary columns to join
slr_districts <- slr_districts %>% 
  select(DistrictNa, slr_area)

# conduct a join, converting the sf objects into dataframes
slr_ca_districts <- full_join(ca_districts %>% as.data.frame(), 
                     slr_districts %>% as.data.frame(), 
                     by = "DistrictNa", keep = FALSE) %>% 
  mutate(area = as.numeric(area), # convert areas to numeric, dropping the units
         slr_area = as.numeric(slr_area)) %>% 
  mutate(slr_area = replace_na(slr_area, 0)) %>% # replace NAs with 0s
  mutate(slr_percent = (slr_area / area) * 100) %>% # calculate sea level rise inundation percentage
  st_sf(sf_column_name = "geometry.x") # convert back to an sf object
```


### preparing for visualization

to visualize in the shiny dashboard, we'll be overlaying schools with sea level rise and coastal storm inundation






